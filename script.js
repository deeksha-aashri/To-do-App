var uid = new ShortUniqueId();  
const addBtn=document.querySelector(".add-btn");
const modalCont=document.querySelector(".modal-cont")
const allPriorityColors=document.querySelectorAll(".priority-color"); //we get the array of  divs of all the four colors
let colors=['lightpink','lightgreen','lightblue','black'];
let modalPriorityColor=colors[colors.length - 1];
const textAreaCont=document.querySelector(".textarea-cont");
const mainCont=document.querySelector(".main-cont");
let ticketsArr = [];  //this array stores the ticket that is its priority color, its ID and its data.

let toolBoxColors = document.querySelectorAll(".color");  //the colored boxes in the navbar
let removeBtn = document.querySelector(".remove-btn");
let lockClass="fa-lock";
let unlockClass="fa-lock-open";

//To open and close a modal container
 let isModalPresent=false; // a flag
 addBtn.addEventListener("click",function(){
     if(!isModalPresent){
         modalCont.style.display="flex"; //if modal is absent and plus is clicked then modal should be displayed
     }
     else{
         modalCont.style.display="none";//else modal is present so, now if we click plus modal should disapppear
     }
     isModalPresent = !isModalPresent; // toggling effect i.e, update flag as the opposite of whatever state it was in
 });

//console.log(allPriorityColors);
 
allPriorityColors.forEach(function(colorElement){ //for each traverse each element of the above received array one-by-one and brings back the colors one-by-one
      colorElement.addEventListener("click", function(){ //whatever colorelement we get, we attach an eventlistener to it
allPriorityColors.forEach(function(priorityColorElem){
    priorityColorElem.classList.remove("active"); //remove active class from all four div classes in case present
});
colorElement.classList.add("active"); //attach active class to the currenttarget
modalPriorityColor = colorElement.classList[0]; //the top of modal will have the color as specified in the 0th element of that class (due to the styling which fills in the bgcolor)
      });
  });


  // If we press shift then the modal should disappear and a ticket should be generated and pasted on main area
   modalCont.addEventListener("keydown",function(e){
   let key = e.key;  //tells us which key has been pressed
   if(key == "Shift"){
     //  console.log(modalPriorityColor);
     //  console.log(textAreaCont.value);// .value???
       createTicket(modalPriorityColor,textAreaCont.value);
       modalCont.style.display="none"; //once you press shift make the modal disappear
       isModalPresent=false;//update flag
       textAreaCont.value=""; // this will ensure that once ticket has been generated and we want another ticket so on modal we will not have the contetnt of the previous ticket written but the placeholder will show default text as, empty string is given on that area
       allPriorityColors.forEach(function(colorElem){
           colorElem.classList.remove("active"); //ensures no color is highlighted when making a new ticket on modal
       });
   }

   });

 
  
  
   //Function to create a new ticket
 function createTicket(ticketcolor, data, ticketId){
    let id = ticketId || uid();  //when a ticket is created for the first time no ticket id is passed. Here id=uid ehich is generated by ShortUnique id
     let ticketCont=document.createElement("div"); //will create a div
     ticketCont.setAttribute("class","ticket-cont");//gives a class to the above created div
     ticketCont.innerHTML=`
     <div class="ticket-color ${ticketcolor}"></div>
     <div class="ticket-id">${id}</div>
     <div class="task-area">${data}</div>
     <div class="ticket-lock">
          <i class="fa-solid fa-lock"></i>
        </div>
     `;
    
     mainCont.appendChild(ticketCont);
 

handleRemoval(ticketCont, id);
handleColor(ticketCont,id);
handleLock(ticketCont,id);

 //If the  ticket is being created for the first time , then ticketId would be undefined
 if (!ticketId) {  //Read: If ticketId is not passed, the following kind of ticket will be pushed in the array. And tickteId(=id) will be the one generated randomly using shortid
     ticketsArr.push(
         {
             ticketcolor,
             data,
             ticketId: id
         }
     );
     localStorage.setItem("tickets", JSON.stringify(ticketsArr)); //ensures that all the tickets formed using this function are stored in the local storage 
     //so that they persist upon refreshing i,e. tickets pasted on the main-cont will not be lost if we refresh the page. L.S. stores objects so, we use stringify to convert it into a string.
 }
};

//get all tickets from local Storage
if (localStorage.getItem("tickets")) {
    ticketsArr = JSON.parse(localStorage.getItem("tickets"));//convert to object
    ticketsArr.forEach(function(ticketObj){
        createTicket(ticketObj.ticketcolor, ticketObj.data, ticketObj.ticketId);
    })
}

//filter tickets on the basis of ticketcolor
for (let i = 0; i < toolBoxColors.length; i++){
    toolBoxColors[i].addEventListener("click", function () {
        let currToolBoxColor = toolBoxColors[i].classList[0];

        let filteredTickets = ticketsArr.filter(function (ticketObj) {//.filter is an in-built function it returns an array.
           if(currToolBoxColor==ticketObj.ticketcolor) {
              return ticketObj;
         }   
                  // Or shortcut :return currToolBoxColor == ticketObj.ticketcolor;
        });

        //remove all the tickets
        let allTickets = document.querySelectorAll(".ticket-cont");
        for (let i = 0; i < allTickets.length; i++){
            allTickets[i].remove();
        }

        //display filteredTickets
        filteredTickets.forEach(function (ticketObj) {
            createTicket(
              ticketObj.ticketcolor,
              ticketObj.data,
              ticketObj.ticketId
            );
        })
    })

    //to display all the tickets of all colors on double clicking
    toolBoxColors[i].addEventListener("dblclick", function () {
      //remove all the color specific tickets 
        let allTickets = document.querySelectorAll(".ticket-cont");  //will have the tickets displayed on the browser so, right now we will have filtered tickets displayed on the browser
      for (let i = 0; i < allTickets.length; i++) {
        allTickets[i].remove();  //all filtered tickets will be removed as they were on the main-cont or the front end.
      }

      //display all Tickets
      ticketsArr.forEach(function (ticketObj) {
        createTicket(ticketObj.ticketcolor, ticketObj.data, ticketObj.ticketId);
      });
    })
}

//To activate removeBtn make its color red that is click on it to make it red.
//To deactivate click the btn again and make it white
let removeBtnActive=false;
removeBtn.addEventListener("click", function(){
    if(removeBtnActive){
        removeBtn.style.color="white";
    }
    else{
        removeBtn.style.color="red";
    }
    removeBtnActive=!removeBtnActive;
});

//While removing tickets from UI, remove them from LS too using handleRemoval

function handleRemoval(ticket,id){
    ticket.addEventListener("click",function(){
        if(!removeBtnActive){
            return;
        }
       
            let idx=getTicketIdx(id);//get the idx of ticket to be deleted. id is unique for each ticket so we use it to obtain the index
            ticketsArr.splice(idx,1);
//Set updates arr on removing from browser storage
            localStorage.setItem("tickets",JSON.stringify(ticketsArr));


            //Remove from the front end
            ticket.remove();
        
    });
}
//Writing the function which returns idx of ticket from LS's array
function getTicketIdx(id){
    let ticketIdx=ticketsArr.findIndex(function(ticketObj){
        return ticketObj.ticketId==id;

    })
    return ticketIdx;
}


//To change the priority color of the tickets on clicking the color strip of the ticket
function handleColor(ticket, id){
    let ticketColorStrip=ticket.querySelector(".ticket-color");

    ticketColorStrip.addEventListener("click",function(){
        let currTicketColor=ticketColorStrip.classList[1];
        let currTicketColorIdx = colors.indexOf(currTicketColor); //0
       
        let newTicketColorIdx=currTicketColorIdx +1;
       
        newTicketColorIdx=newTicketColorIdx % colors.length;//to ensure after black pink comes again
        let newTicketColor=colors[newTicketColorIdx];

        ticketColorStrip.classList.remove(currTicketColor);
        ticketColorStrip.classList.add(newTicketColor);

        //To update the change of strip color in local storage
        let ticketIdx=getTicketIdx(id);
        ticketsArr[ticketIdx].ticketcolor=newTicketColor;
        localStorage.setItem("tickets",JSON.stringify(ticketsArr))
    });
}




//Lock and Unlock t9io make content editable true and false
function handleLock(ticket,id){

    let ticketLockEle=ticket.querySelector(".ticket-lock");
    let ticketLock=ticketLockEle.children[0];
    let ticketTaskArea=ticket.querySelector(".task-area");

    //Toggle of icons and contentediatable property
    ticketLock.addEventListener("click",function(){
    let ticketIdx=getTicketIdx(id);
    if(ticketLock.classList.contains(lockClass)){
        ticketLock.classList.remove(lockClass);
        ticketLock.classList.add(unlockClass);
        ticketTaskArea.setAttribute("contenteditable", "true");
    }
    else{  //if lock is open
        ticketLock.classList.remove(unlockClass);
        ticketLock.classList.add(lockClass);
        ticketTaskArea.setAttribute("contenteditable","false");
    }

    ticketsArr[ticketIdx].data=ticketTaskArea.innerText;
    localStorage.setItem("tickets", JSON.stringify(ticketsArr));
    });
    }
   


